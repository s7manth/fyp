
## Logistic Regression Chapter 5

"And how do you know that these fine begonias are not of equal importance?"
Hercule Poirot, in Agatha Christie's The Mysterious Affair at Styles Detective stories are as littered with clues as texts are with words. Yet for the poor reader it can be challenging to know how to weigh the author's clues in order to make the crucial classification task: deciding whodunnit.

In this chapter we introduce an algorithm that is admirably suited for discovering the link between features or cues and some particular outcome: **logistic regression**.

logistic regression Indeed, logistic regression is one of the most important analytic tools in the social and natural sciences. In natural language processing, logistic regression is the baseline supervised machine learning algorithm for classification, and also has a very close relationship with neural networks. As we will see in Chapter 7, a neural network can be viewed as a series of logistic regression classifiers stacked on top of each other. Thus the classification and machine learning techniques introduced here will play an important role throughout the book.

Logistic regression can be used to classify an observation into one of two classes
(like 'positive sentiment' and 'negative sentiment'), or into one of many classes. Because the mathematics for the two-class case is simpler, we'll describe this special case of logistic regression first in the next few sections, and then briefly summarize the use of **multinomial logistic regression** for more than two classes in Section 5.3.

We'll introduce the mathematics of logistic regression in the next few sections.

But let's begin with some high-level issues.

Generative and Discriminative Classifiers:
The most important difference between naive Bayes and logistic regression is that logistic regression is a discriminative classifier while naive Bayes is a **generative** classifier.

These are two very different frameworks for how to build a machine learning model. Consider a visual metaphor: imagine we're trying to distinguish dog images from cat images. A generative model would have the goal of understanding what dogs look like and what cats look like. You might literally ask such a model to 'generate', i.e., draw, a dog. Given a test image, the system then asks whether it's the cat model or the dog model that better fits (is less surprised by) the image, and chooses that as its label.

A discriminative model, by contrast, is only trying to learn to distinguish the classes (perhaps without learning much about them). So maybe all the dogs in the training data are wearing collars and the cats aren't. If that one feature neatly separates the classes, the model is satisfied.

If you ask such a model what it knows about cats all it can say is that they don't wear collars.

More formally, recall that the naive Bayes assigns a class c to a document d not by directly computing P(c|d) but by computing a likelihood and a prior

$$\hat{c}=\operatorname*{argmax}_{c\in C}\quad\widehat{P(d|c)}\quad\widehat{P(c)}\tag{5.1}$$

generalise

A generative model like naive Bayes makes use of this **likelihood** term, which is a consequence of the fact that a correction of the 
expresses how to generate the features of a document *if we knew it was of class c*.

By contrast a **discriminative model** in this text categorization scenario attempts discriminative model to **directly** compute P(c|d). Perhaps it will learn to assign a high weight to document features that directly improve its ability to *discriminate* between possible classes, even if it couldn't generate an example of one of the classes.

Components of a probabilistic machine learning classifier:
Like naive Bayes, logistic regression is a probabilistic classifier that makes use of supervised machine learning. Machine learning classifiers require a training corpus of m input/output pairs (x(i),y(i)). (We'll use superscripts in parentheses to refer to individual instances in the training set—for sentiment classification each instance might be an individual document to be classified.) A machine learning system for classification then has four components:

1. A **feature representation** of the input. For each input observation x(i), this
will be a vector of features [x1,x2*,...,*xn]. We will generally refer to feature
i for input x(j) as x(j)
i , sometimes simplified as xi, but we will also see the
notation fi, fi(x), or, for multiclass classification, fi(c,x).
2. A classification function that computes ˆy, the estimated class, via p(y|x). In
the next section we will introduce the **sigmoid** and **softmax** tools for classification.
3. An objective function for learning, usually involving minimizing error on
training examples. We will introduce the **cross-entropy loss function**.
4. An algorithm for optimizing the objective function. We introduce the stochastic gradient descent algorithm.
Logistic regression has two phases:

training: We train the system (specifically the weights w and b) using stochastic
gradient descent and the cross-entropy loss.
test: Given a test example x we compute p(y|x) and return the higher probability
label y = 1 or y = 0.

## 5.1 The Sigmoid Function

The goal of binary logistic regression is to train a classifier that can make a binary decision about the class of a new input observation. Here we introduce the sigmoid classifier that will help us make this decision.

Consider a single input observation x, which we will represent by a vector of features [x1,x2*,...,*xn] (we'll show sample features in the next subsection). The classifier output y can be 1 (meaning the observation is a member of the class) or 0 (the observation is not a member of the class). We want to know the probability P(y = 1|x)
that this observation is a member of the class. So perhaps the decision is "positive sentiment" versus "negative sentiment", the features represent counts of words in a document, P(y = 1|x) is the probability that the document has positive sentiment, and P(y = 0|x) is the probability that the document has negative sentiment.

Logistic regression solves this task by learning, from a training set, a vector of weights and a **bias term**. Each weight wi is a real number, and is associated with one of the input features xi. The weight wi represents how important that input feature is to the classification decision, and can be positive (providing evidence that the instance being classified belongs in the positive class) or negative (providing evidence that the instance being classified belongs in the negative class). Thus we might expect in a sentiment task the word *awesome* to have a high positive weight, and abysmal to have a very negative weight. The **bias term**, also called the **intercept**, is bias term

another real number that's added to the weighted inputs.

To make a decision on a test instance--after we've learned the weights in training--the classifier first multiplies each $x_{i}$ by its weight $w_{i}$, sums up the weighted features, and adds the bias term $b$. The resulting single number $z$ expresses the weighted sum of the evidence for the class.

$$z\ =\ \left(\sum_{i=1}^{n}w_{i}x_{i}\right)+b\tag{5.2}$$

**data product** In the rest of the book we'll represent such sums using the **dot product** notation 
from linear algebra. The dot product of two vectors a and b, written as a · b, is the sum of the products of the corresponding elements of each vector. (Notice that we represent vectors using the boldface notation b). Thus the following is an equivalent formation to Eq. 5.2:

$\overline{\Sigma}=\overline{\psi}\cdot\overline{\chi}+b$ (5.3)
But note that nothing in Eq. 5.3 forces z to be a legal probability, that is, to lie between 0 and 1. In fact, since weights are real-valued, the output might even be negative; z ranges from −∞ to ∞.

To create a probability, we'll pass z through the **sigmoid** function, σ(z). The sigmoid

| sigmoid function (named because it looks like an                                  |    s | ) is also called the   |
|-----------------------------------------------------------------------------------|------|------------------------|
| logistic func-                                                                    |      |                        |
| tion                                                                              |      |                        |
| , and gives logistic regression its name. The sigmoid has the following equation, |      |                        |
| logistic                                                                          |      |                        |
| function                                                                          |      |                        |
| shown graphically in Fig.                                                         |  5.1 | :                      |

$$\sigma(z)=\frac{1}{1+e^{-z}}=\frac{1}{1+\exp{(-z)}}\tag{5.4}$$

(For the rest of the book, we'll use the notation $\exp(x)$ to mean $e^{x}$.) The sigmoid has a number of advantages; it takes a real-valued number and maps it into the range 
(0,1), which is just what we want for a probability. Because it is nearly linear around
0 but flattens toward the ends, it tends to squash outlier values toward 0 or 1. And it's differentiable, which as we'll see in Section 5.10 will be handy for learning.

We're almost there. If we apply the sigmoid to the sum of the weighted features, we get a number between 0 and 1. To make it a probability, we just need to make sure that the two cases, p(y = 1) and p(y = 0), sum to 1. We can do this as follows:

$$P(y=1)=\sigma(\mathbf{w}\cdot\mathbf{x}+b)\tag{5.5}$$ $$=\frac{1}{1+\exp\left(-(\mathbf{w}\cdot\mathbf{x}+b)\right)}$$ $$P(y=0)=1-\sigma(\mathbf{w}\cdot\mathbf{x}+b)$$ $$=1-\frac{1}{1+\exp\left(-(\mathbf{w}\cdot\mathbf{x}+b)\right)}$$ $$=\frac{\exp\left(-(\mathbf{w}\cdot\mathbf{x}+b)\right)}{1+\exp\left(-(\mathbf{w}\cdot\mathbf{x}+b)\right)}$$
The sigmoid function has the property

$1-\sigma(x)=\sigma(-x)$
so we could also have expressed P(y = 0) as σ(−(w ·x+b)).

Finally, one terminological point. The input to the sigmoid function, the score z = w · x + b from (5.3), is often called the **logit**. This is because the logit function logit is the inverse of the sigmoid. The logit function is the log of the odds ratio p
1−p:

$$\text{logit}(p)=\sigma^{-1}(p)=\ln\frac{p}{1-p}\tag{5.7}$$

Using the term **logit** for $z$ is a way of reminding us that by using the sigmoid to turn $z$ (which ranges from $-\infty$ to $\infty$) into a probability, we are implicitly interpreting $z$ as not just any real-valued number, but as specifically a log odds.

## 5.2 Classification With Logistic Regression

The sigmoid function from the prior section thus gives us a way to take an instance $x$ and compute the probability $P(y=1|x)$.

How do we make a decision about which class to apply to a test instance $x$? For a given $x$, we say yes if the probability $P(y=1|x)$ is more than.5, and no otherwise. We call.5 the **decision boundary**:

$$\mbox{decision}(x)\ =\ \left\{\begin{array}{ll}1&\mbox{if}\ P(y=1|x)>0.5\\ 0&\mbox{otherwise}\end{array}\right.$$
Let's have some examples of applying logistic regression as a classifier for language tasks.

## 5.2.1 Sentiment Classification

Suppose we are doing binary sentiment classification on movie review text, and we would like to know whether to assign the sentiment class + or − to a review document *doc*. We'll represent each input observation by the 6 features x1 *...*x6 of the input shown in the following table; Fig. 5.2 shows the features in a sample mini test document.

| Var                          |
|------------------------------|
| x                            |
| 1                            |
| count(positive lexicon words |
| ∈                            |
| doc                          |
| )                            |
| 3                            |
| x                            |
| 2                            |
| count(negative lexicon words |
| ∈                            |
| doc                          |
| )                            |
| 2                            |
| x                            |
| 3                            |
|                              |
| 1 if "no"                    |
| ∈                            |
| doc                          |
| 0 otherwise                  |
| 1                            |
| x                            |
| 4                            |
| count                        |
| (                            |
| 1st and 2nd pronouns         |
| ∈                            |
| doc                          |
| )                            |
| 3                            |
| x                            |
| 5                            |
|                              |
| 1 if "!"                     |
| ∈                            |
| doc                          |
| 0 otherwise                  |
| 0                            |
| x                            |
| 6                            |
| ln                           |
| (                            |
| word count of doc            |
| )                            |
| ln                           |
| (                            |
| 66                           |
| ) =                          |
| 4                            |
| .                            |
| 19                           |

Let's assume for the moment that we've already learned a real-valued weight for It's hokey . There are virtually no surprises , and the writing is second-rate . So why was it so enjoyable  ? For one thing , the cast is great . Another nice touch is the music . I was overcome with the urge to get off the couch and start dancing .  It sucked me in , and it'll do the same to you  .

each of these features, and that the 6 weights corresponding to the 6 features are
[2.5,−5.0,−1.2,0.5,2.0,0.7], while b = 0.1. (We'll discuss in the next section how the weights are learned.) The weight w1, for example indicates how important a feature the number of positive lexicon words (great, nice, *enjoyable*, etc.) is to a positive sentiment decision, while w2 tells us the importance of negative lexicon words. Note that w1 = 2.5 is positive, while w2 = −5.0, meaning that negative words are negatively associated with a positive sentiment decision, and are about twice as important as positive words.

Given these 6 features and the input review x, P(+|x) and P(−|x) can be computed using Eq. 5.5:

$$p(+|x)=P(y=1|x)=\sigma(\mathbf{w}\cdot\mathbf{x}+b)\tag{5.8}$$ $$=\sigma([2.5,-5.0,-1.2,0.5,2.0,0.7]\cdot[3,2,1,3,0,4.19]+0.1)$$ $$=\sigma(.833)$$ $$=0.70$$ $$p(-|x)=P(y=0|x)=1-\sigma(\mathbf{w}\cdot\mathbf{x}+b)$$ $$=0.30$$

## 5.2.2 Other Classification Tasks And Features

Logistic regression is commonly applied to all sorts of NLP tasks, and any property of the input can be a feature. Consider the task of **period disambiguation**: deciding period disambiguation

if a period is the end of a sentence or part of a word, by classifying each period into one of two classes EOS (end-of-sentence) and not-EOS. We might use features like $x_{1}$ below expressing that the current word is lower case (perhaps with a positive weight), or that the current word is in our abbreviations dictionary ("Prof.") (perhaps with a negative weight). A feature can also express a quite complex combination of properties. For example a period following an upper case word is likely to be an EOS, but if the word itself is $St$, and the previous word is capitalized, then the period is likely part of a shortening of the word $stree$.

$$x_{1}=\left\{\begin{array}{ll}1&\mbox{if``\emph{Case}(w_{i})=\mbox{Lower"}}\\ 0&\mbox{otherwise}\end{array}\right.$$ $$x_{2}=\left\{\begin{array}{ll}1&\mbox{if``\emph{w}_{i}\in\mbox{\it AcronymDict"}}\\ 0&\mbox{otherwise}\end{array}\right.$$ $$x_{3}=\left\{\begin{array}{ll}1&\mbox{if``\emph{w}_{i}=\mbox{St.\&\emph{Case}(w_{i-1})=\mbox{Cap"}}\\ 0&\mbox{otherwise}\end{array}\right.$$
Designing features:
Features are generally designed by examining the training set with an eye to linguistic intuitions and the linguistic literature on the domain. A careful error analysis on the training set or devset of an early version of a system often provides insights into features.

For some tasks it is especially helpful to build complex features that are combinations of more primitive features. We saw such a feature for period disambiguation above, where a period on the word *St.* was less likely to be the end of the sentence if the previous word was capitalized. For logistic regression and naive Bayes these combination features or **feature interactions** have to be designed by hand.

feature interactions For many tasks (especially when feature values can reference specific words)
we'll need large numbers of features. Often these are created automatically via feature templates, abstract specifications of features. For example a bigram template feature templates for period disambiguation might create a feature for every pair of words that occurs before a period in the training set. Thus the feature space is sparse, since we only have to create a feature if that n-gram exists in that position in the training set. The feature is generally created as a hash from the string descriptions. A user description of a feature as, "bigram(American breakfast)" is hashed into a unique integer i that becomes the feature number fi.

In order to avoid the extensive human effort of feature design, recent research in NLP has focused on **representation learning**: ways to learn features automatically in an unsupervised way from the input. We'll introduce methods for representation learning in Chapter 6 and Chapter 7.

Scaling input features:
When different input features have extremely different ranges of values, it's common to rescale them so they have comparable ranges. We standardize input values by centering them to result in a zero mean and a standard standardize deviation of one (this transformation is sometimes called the **z-score**). That is, if µi z-score

is the mean of the values of feature $x_{i}$ across the $m$ observations in the input dataset, and $\sigma_{i}$ is the standard deviation of the values of features $x_{i}$ across the input dataset, we can replace each feature $x_{i}$ by a new feature $x_{i}^{\prime}$ computed as follows:

$$\mu_{i}=\frac{1}{m}\sum_{j=1}^{m}x_{i}^{(j)}\sigma_{i}=\sqrt{\frac{1}{m}\sum_{j=1}^{m}\left(x_{i}^{(j)}-\mu_{i}\right)^{2}}$$ $$x_{i}^{\prime}=\frac{x_{i}-\mu_{i}}{\sigma_{i}}\tag{5.9}$$
Alternatively, we can **normalize** the input features values to lie between 0 and 1:
normalize

$$x_{i}^{\prime}=\frac{x_{i}-\min(x_{i})}{\max(x_{i})-\min(x_{i})}\tag{5.10}$$
Having input data with comparable range is useful when comparing values across features. Data scaling is especially important in large neural networks, since it helps speed up gradient descent.

## 5.2.3 Processing Many Examples At Once

We've shown the equations for logistic regression for a single example. But in practice we'll of course want to process an entire test set with many examples. Let's suppose we have a test set consisting of m test examples each of which we'd like to classify. We'll continue to use the notation from page 2, in which a superscript value in parentheses refers to the example index in some set of data (either for training or for test). So in this case each test example x(i) has a feature vector x(i), 1 ≤ i ≤ m.

(As usual, we'll represent vectors and matrices in bold.)
One way to compute each output value ˆy(i) is just to have a for-loop, and compute each test example one at a time:

foreach $x^{(i)}$ in input $[x^{(1)},x^{(2)},...,x^{(m)}]$

$$y^{(i)}=\sigma(\mathbf{w}\cdot\mathbf{x}^{(\mathbf{i})}+b)\tag{5.11}$$
For the first 3 test examples, then, we would be separately computing the predicted ˆy(i) as follows:

P(y(1) = 1|x(1)) = σ(w ·x(1) +b) P(y(2) = 1|x(2)) = σ(w ·x(2) +b) P(y(3) = 1|x(3)) = σ(w ·x(3) +b)
But it turns out that we can slightly modify our original equation Eq. 5.5 to do this much more efficiently. We'll use matrix arithmetic to assign a class to all the examples with one matrix operation!

First, we'll pack all the input feature vectors for each input x into a single input matrix X, where each row i is a row vector consisting of the feature vector for input example x(i) (i.e., the vector x(i)). Assuming each example has f features and weights, X will therefore be a matrix of shape [m× f], as follows:

  X = (5.12) x(1) 1 x(1) 2 ... x(1) f x(2) 1 x(2) 2 ... x(2) f x(3) 1 x(3) 2 ... x(3) f ... 


Now if we introduce $\mathbf{b}$ as a vector of length $m$ which consists of the scalar bias term $b$ repeated $m$ times, $\mathbf{b}=[b,b,...,b]$, and $\mathbf{\hat{y}}=[\hat{y}^{(1)},\hat{y}^{(2)},...,\hat{y}^{(m)}]$ as the vector of outputs (one scalar $\hat{y}^{(i)}$ for each input $x^{(i)}$ and its feature vector $\mathbf{x}^{(i)}$), and represent the weight vector $\mathbf{w}$ as a column vector, we can compute all the outputs with a single matrix multiplication and one addition:

$$\mathbf{y}\ =\ \mathbf{Xw+b}\tag{5.13}$$
You should convince yourself that Eq. 5.13 computes the same thing as our for-loop in Eq. 5.11. For example ˆy(1), the first entry of the output vector y, will correctly be:

$$\hat{y}^{(1)}=[x_{1}^{(1)},x_{2}^{(1)},...,x_{f}^{(1)}]\cdot[w_{1},w_{2},...,w_{f}]+b\tag{5.14}$$
Note that we had to reorder X and w from the order they appeared in in Eq. 5.5 to make the multiplications come out properly. Here is Eq. 5.13 again with the shapes shown:

$$\begin{array}{ccccc}\mathbf{y}&=&\mathbf{\chi}&\mathbf{w}&+&\mathbf{b}\\ (m\times1)&(m\times f)(f\times1)&(m\times1)\end{array}\tag{5.15}$$
Modern compilers and compute hardware can compute this matrix operation very efficiently, making the computation much faster, which becomes important when training or testing on very large datasets.

## 5.2.4 Choosing A Classifier

Logistic regression has a number of advantages over naive Bayes. Naive Bayes has overly strong conditional independence assumptions. Consider two features which are strongly correlated; in fact, imagine that we just add the same feature f1 twice.

Naive Bayes will treat both copies of f1 as if they were separate, multiplying them both in, overestimating the evidence. By contrast, logistic regression is much more robust to correlated features; if two features f1 and f2 are perfectly correlated, regression will simply assign part of the weight to w1 and part to w2. Thus when there are many correlated features, logistic regression will assign a more accurate probability than naive Bayes. So logistic regression generally works better on larger documents or datasets and is a common default.

Despite the less accurate probabilities, naive Bayes still often makes the correct classification decision. Furthermore, naive Bayes can work extremely well (sometimes even better than logistic regression) on very small datasets (Ng and Jordan, 2002) or short documents (Wang and Manning, 2012). Furthermore, naive Bayes is easy to implement and very fast to train (there's no optimization step). So it's still a reasonable approach to use in some situations.

## 5.3 Multinomial Logistic Regression

Sometimes we need more than two classes. Perhaps we might want to do 3-way sentiment classification (positive, negative, or neutral). Or we could be assigning some of the labels we will introduce in Chapter 8, like the part of speech of a word (choosing from 10, 30, or even 50 different parts of speech), or the named entity type of a phrase (choosing from tags like person, location, organization).

In such cases we use **multinomial logistic regression**, also called softmax remultinomial logistic regression gression (in older NLP literature you will sometimes see the name maxent classifier). In multinomial logistic regression we want to label each observation with a class k from a set of K classes, under the stipulation that only one of these classes is the correct one (sometimes called **hard classification**; an observation can not be in multiple classes). Let's use the following representation: the output y for each input x will be a vector of length K. If class c is the correct class, we'll set yc = 1, and set all the other elements of y to be 0, i.e., yc = 1 and yj = 0 ∀ j ̸= c. A vector like this y, with one value=1 and the rest 0, is called a **one-hot vector**. The job of the classifier is to produce an estimate vector ˆy. For each class k, the value ˆyk will be the classifier's estimate of the probability p(yk = 1|x).

## 5.3.1 Softmax

The multinomial logistic classifier uses a generalization of the sigmoid, called the softmax function, to compute p(yk = 1|x). The softmax function takes a vector softmax z = [z1,z2*,...,*zK] of K arbitrary values and maps them to a probability distribution, with each value in the range [0,1], and all the values summing to 1. Like the sigmoid, it is an exponential function.

For a vector z of dimensionality K, the softmax is defined as:

$$\text{softmax}(z_{i})\ =\ \frac{\exp{(z_{i})}}{\sum_{j=1}^{K}\exp{(z_{j})}}\ \ 1\leq i\leq K\tag{5.16}$$

The softmax of an input vector $\mathbf{z}=[z_{1},z_{2},...,z_{K}]$ is thus a vector itself:

$$\text{softmax}(\mathbf{z})\ =\ \left[\frac{\exp{(z_{1})}}{\sum_{i=1}^{K}\exp{(z_{i})}},\frac{\exp{(z_{2})}}{\sum_{i=1}^{K}\exp{(z_{i})}},...,\frac{\exp{(z_{K})}}{\sum_{i=1}^{K}\exp{(z_{i})}}\right]\tag{5.17}$$

The denominator $\sum_{i=1}^{K}\exp{(z_{i})}$ is used to normalize all the values into probabilities. Thus for example given a vector:

$$\mathbf{z}=[0.6,1.1,-1.5,1.2,3.2,-1.1]$$
the resulting (rounded) softmax(z) is

$$[0.055,0.090,0.006,0.099,0.74,0.010]$$
Like the sigmoid, the softmax has the property of squashing values toward 0 or 1.

Thus if one of the inputs is larger than the others, it will tend to push its probability toward 1, and suppress the probabilities of the smaller inputs.

Finally, note that, just as for the sigmoid, we refer to z, the vector of scores that is the input to the softmax, as **logits** (see (5.7).

## 5.3.2 Applying Softmax In Logistic Regression

When we apply softmax for logistic regression, the input will (just as for the sigmoid) be the dot product between a weight vector w and an input vector x (plus a bias). But now we'll need separate weight vectors wk and bias bk for each of the K
classes. The probability of each of our output classes ˆyk can thus be computed as:

$$p(y_{k}=1|\mathbf{x})=\frac{\exp\left(\mathbf{w}_{k}\cdot\mathbf{x}+b_{k}\right)}{\sum_{j=1}^{K}\exp\left(\mathbf{w}_{j}\cdot\mathbf{x}+b_{j}\right)}$$
The form of Eq. 5.18 makes it seem that we would compute each output separately. Instead, it's more common to set up the equation for more efficient computation by modern vector processing hardware. We'll do this by representing the set of K weight vectors as a weight matrix W and a bias vector b. Each row k of W corresponds to the vector of weights wk. W thus has shape [K × f], for K the number of output classes and f the number of input features. The bias vector b has one value for each of the K output classes. If we represent the weights in this way, we can compute ˆy, the vector of output probabilities for each of the K classes, by a single elegant equation:

$\hat{\bf y}=\mbox{softmax}({\bf Wx}+{\bf b})$ (5.19)
If you work out the matrix arithmetic, you can see that the estimated score of the first output class ˆy1 (before we take the softmax) will correctly turn out to be w1 ·x+b1.

Fig. 5.3 shows an intuition of the role of the weight vector versus weight matrix in the computation of the output class probabilities for binary versus multinomial logistic regression.

## 5.3.3 Features In Multinomial Logistic Regression

Features in multinomial logistic regression act like features in binary logistic regression, with the difference mentioned above that we'll need separate weight vectors and biases for each of the K classes. Recall our binary exclamation point feature x5
from page 5:

$$x_{5}~=~{\left\{\begin{array}{l l}{1}&{{\mathrm{if~``1''\in d o c}}}\\ {0}&{{\mathrm{otherwise}}}\end{array}\right.}$$
In binary classification a positive weight w5 on a feature influences the classifier toward y = 1 (positive sentiment) and a negative weight influences it toward y = 0
(negative sentiment) with the absolute value indicating how important the feature is. For multinomial logistic regression, by contrast, with separate weights for each class, a feature can be evidence for or against each individual class.

In 3-way multiclass sentiment classification, for example, we must assign each document one of the 3 classes +, −, or 0 (neutral). Now a feature related to exclamation marks might have a negative weight for 0 documents, and a positive weight for + or − documents:

\begin{tabular}{l c c c} Feature & Definition & $W_{5,+}$ & $W_{5,-}$ & $W_{5,0}$ \\ $f_{5}(x)$ & $\left\{\begin{array}{ll}1&\mbox{if``1''}\in\mbox{doc}\\ 0&\mbox{otherwise}\end{array}\right.$ & 3.5 & 3.1 & $-5.3$ \\ \end{tabular}

Because these feature weights are dependent both on the input text and the output class, we sometimes make this dependence explicit and represent the features themselves as f(x,y): a function of both the input and the class. Using such a notation f5(x) above could be represented as three features f5(x,+), f5(x,−), and f5(x,0), each of which has a single weight. We'll use this kind of notation in our description of the CRF in Chapter 8.

## 5.4 Learning In Logistic Regression

How are the parameters of the model, the weights w and bias b, learned? Logistic regression is an instance of supervised classification in which we know the correct label y (either 0 or 1) for each observation x. What the system produces via Eq. 5.5 is ˆy, the system's estimate of the true y. We want to learn parameters (meaning w and b) that make ˆy for each training observation as close as possible to the true y.

This requires two components that we foreshadowed in the introduction to the chapter. The first is a metric for how close the current label (ˆy) is to the true gold label y. Rather than measure similarity, we usually talk about the opposite of this: the *distance* between the system output and the gold output, and we call this distance the **loss** function or the **cost function**. In the next section we'll introduce the loss loss

function that is commonly used for logistic regression and also for neural networks,
the **cross-entropy loss**.
The second thing we need is an optimization algorithm for iteratively updating
the weights so as to minimize this loss function. The standard algorithm for this is
gradient descent; we'll introduce the **stochastic gradient descent** algorithm in the
following section.

## Logistic Regression

We'll describe these algorithms for the simpler case of binary logistic regression in the next two sections, and then turn to multinomial logistic regression in Section 5.8.

## 5.5 The Cross-Entropy Loss Function

We need a loss function that expresses, for an observation x, how close the classifier output (ˆy = σ(w ·x+b)) is to the correct output (y, which is 0 or 1). We'll call this:

$L(\hat{y},y)=$ How much $\hat{y}$ differs from the true $y$ (5.20)
We do this via a loss function that prefers the correct class labels of the training examples to be *more likely*. This is called conditional maximum likelihood estimation: we choose the parameters w,b that maximize the log probability of the true y **labels in the training data** given the observations x. The resulting loss function is the **negative log likelihood loss**, generally called the **cross-entropy loss**.

cross-entropy loss Let's derive this loss function, applied to a single observation x. We'd like to learn weights that maximize the probability of the correct label p(y|x). Since there are only two discrete outcomes (1 or 0), this is a Bernoulli distribution, and we can express the probability p(y|x) that our classifier produces for one observation as the following (keeping in mind that if y = 1, Eq. 5.21 simplifies to ˆy; if y = 0, Eq. 5.21
simplifies to 1− ˆy):

$$p(y|x)=\hat{y}^{y}\left(1-\hat{y}\right)^{1-y}\tag{5.21}$$
Now we take the log of both sides. This will turn out to be handy mathematically, and doesn't hurt us; whatever values maximize a probability will also maximize the log of the probability:

$$\log p(y|x)=\log\left[\hat{y}^{y}\left(1-\hat{y}\right)^{1-y}\right]\tag{5.22}$$ $$=y\log\hat{y}+(1-y)\log(1-\hat{y})$$
Eq. 5.22 describes a log likelihood that should be maximized. In order to turn this into a loss function (something that we need to minimize), we'll just flip the sign on Eq. 5.22. The result is the cross-entropy loss LCE:

$$L_{\rm CE}(\hat{y},y)=-\log p(y|x)\ =\ -\left[y\log\hat{y}+(1-y)\log(1-\hat{y})\right]\tag{5.23}$$
Finally, we can plug in the definition of ˆy = σ(w ·x+b):

$$L_{\rm CE}(\hat{y},y)=-\left[y\log\sigma({\bf w}\cdot{\bf x}+b)+(1-y)\log\left(1-\sigma({\bf w}\cdot{\bf x}+b)\right)\right]\tag{5.24}$$
Let's see if this loss function does the right thing for our example from Fig. 5.2. We want the loss to be smaller if the model's estimate is close to correct, and bigger if the model is confused. So first let's suppose the correct gold label for the sentiment example in Fig. 5.2 is positive, i.e., y = 1. In this case our model is doing well, since from Eq. 5.8 it indeed gave the example a higher probability of being positive (.70)
than negative (.30). If we plug σ(w ·x+b) = .70 and y = 1 into Eq. 5.24, the right side of the equation drops out, leading to the following loss (we'll use log to mean natural log when the base is not specified):

$$L_{\rm CE}(\hat{y},y)=-[y\log\sigma({\bf w}\cdot{\bf x}+b)+(1-y)\log\left(1-\sigma({\bf w}\cdot{\bf x}+b)\right)]$$ $$=-\left[\log\sigma({\bf w}\cdot{\bf x}+b)\right]$$ $$=-\log(.70)$$ $$=.36$$
By contrast, let's pretend instead that the example in Fig. 5.2 was actually negative, i.e., y = 0 (perhaps the reviewer went on to say "But bottom line, the movie is terrible! I beg you not to see it!"). In this case our model is confused and we'd want the loss to be higher. Now if we plug y = 0 and 1−σ(w ·x+b) = .31 from Eq. 5.8
into Eq. 5.24, the left side of the equation drops out:

$$L_{\rm CE}(\hat{y},y)=-[y\log\sigma({\bf w}\cdot{\bf x}+b)+(1-y)\log\left(1-\sigma({\bf w}\cdot{\bf x}+b)\right)]$$ $$=-\left[\log\left(1-\sigma({\bf w}\cdot{\bf x}+b)\right)\right]$$ $$=-\log\left(.30\right)$$ $$=1.2$$
Sure enough, the loss for the first classifier (.36) is less than the loss for the second classifier (1.2).

Why does minimizing this negative log probability do what we want? A perfect classifier would assign probability 1 to the correct outcome (y = 1 or y = 0) and probability 0 to the incorrect outcome. That means if y equals 1, the higher ˆy is (the closer it is to 1), the better the classifier; the lower ˆy is (the closer it is to 0), the worse the classifier. If y equals 0, instead, the higher 1− ˆy is (closer to 1), the better the classifier. The negative log of ˆy (if the true y equals 1) or 1 − ˆy (if the true y equals 0) is a convenient loss metric since it goes from 0 (negative log of 1, no loss) to infinity (negative log of 0, infinite loss). This loss function also ensures that as the probability of the correct answer is maximized, the probability of the incorrect answer is minimized; since the two sum to one, any increase in the probability of the correct answer is coming at the expense of the incorrect answer. It's called the crossentropy loss, because Eq. 5.22 is also the formula for the **cross-entropy** between the true probability distribution y and our estimated distribution ˆy.

Now we know what we want to minimize; in the next section, we'll see how to find the minimum.

## 5.6 Gradient Descent

Our goal with gradient descent is to find the optimal weights: minimize the loss function we've defined for the model. In Eq. 5.25 below, we'll explicitly represent the fact that the loss function L is parameterized by the weights, which we'll refer to in machine learning in general as θ (in the case of logistic regression θ = w,b).

So the goal is to find the set of weights which minimizes the loss function, averaged over all examples:

$$\hat{\theta}=\underset{\theta}{\operatorname{argmin}}\frac{1}{m}\sum_{i=1}^{m}L_{\text{CE}}(f(x^{(i)};\theta),y^{(i)})\tag{5.25}$$

How shall we find the minimum of this (or any) loss function? Gradient descent is a method that finds a minimum of a function by figuring out in which direction (in the 
space of the parameters θ) the function's slope is rising the most steeply, and moving in the opposite direction. The intuition is that if you are hiking in a canyon and trying to descend most quickly down to the river at the bottom, you might look around yourself 360 degrees, find the direction where the ground is sloping the steepest, and walk downhill in that direction.

For logistic regression, this loss function is conveniently **convex**. A convex funcconvex tion has at most one minimum; there are no local minima to get stuck in, so gradient descent starting from any point is guaranteed to find the minimum. (By contrast, the loss for multi-layer neural networks is non-convex, and gradient descent may get stuck in local minima for neural network training and never find the global optimum.)
Although the algorithm (and the concept of gradient) are designed for direction vectors, let's first consider a visualization of the case where the parameter of our system is just a single scalar w, shown in Fig. 5.4.

Given a random initialization of w at some value w1, and assuming the loss function L happened to have the shape in Fig. 5.4, we need the algorithm to tell us whether at the next iteration we should move left (making w2 smaller than w1) or right (making w2 bigger than w1) to reach the minimum.

The gradient descent algorithm answers this question by finding the gradient gradient of the loss function at the current point and moving in the opposite direction. The gradient of a function of many variables is a vector pointing in the direction of the greatest increase in a function. The gradient is a multi-variable generalization of the slope, so for a function of one variable like the one in Fig. 5.4, we can informally think of the gradient as the slope. The dotted line in Fig. 5.4 shows the slope of this hypothetical loss function at point w = w1. You can see that the slope of this dotted line is negative. Thus to find the minimum, gradient descent tells us to go in the opposite direction: moving w in a positive direction.

The magnitude of the amount to move in gradient descent is the value of the slope d dwL(f(x;w),y) weighted by a **learning rate** η. A higher (faster) learning learning rate rate means that we should move w more on each step. The change we make in our parameter is the learning rate times the gradient (or the slope, in our single-variable example):

$$w^{t+1}=w^{t}-\eta\frac{d}{dw}L(f(x;w),y)\tag{5.26}$$
Now let's extend the intuition from a function of one scalar variable w to many variables, because we don't just want to move left or right, we want to know where in the N-dimensional space (of the N parameters that make up θ) we should move.

The **gradient** is just such a vector; it expresses the directional components of the sharpest slope along each of those N dimensions. If we're just imagining two weight dimensions (say for one weight w and one bias b), the gradient might be a vector with two orthogonal components, each of which tells us how much the ground slopes in the w dimension and in the b dimension. Fig. 5.5 shows a visualization of the value of a 2-dimensional gradient vector taken at the red point.

In an actual logistic regression, the parameter vector w is much longer than 1 or
2, since the input feature vector x can be quite long, and we need a weight wi for each xi. For each dimension/variable wi in w (plus the bias b), the gradient will have a component that tells us the slope with respect to that variable. In each dimension wi, we express the slope as a partial derivative
∂
∂wi of the loss function. Essentially we're asking: "How much would a small change in that variable wi influence the total loss function L?"
Formally, then, the gradient of a multi-variable function f is a vector in which each component expresses the partial derivative of f with respect to one of the variables. We'll use the inverted Greek delta symbol ∇ to refer to the gradient, and represent ˆy as f(x;θ) to make the dependence on θ more obvious:

$$\nabla L(f(x;\theta),y)=\begin{bmatrix}\frac{\partial}{\partial\theta_{1}}L(f(x;\theta),y)\\ \frac{\partial}{\partial\theta_{2}}L(f(x;\theta),y)\\ \vdots\\ \frac{\partial}{\partial\theta_{m}}L(f(x;\theta),y)\\ \frac{\partial}{\partial\theta_{n}}L(f(x;\theta),y)\end{bmatrix}\tag{5.27}$$

The final equation for updating $\theta$ based on the gradient is thus

$$\theta^{t+1}=\theta^{t}-\eta\nabla L(f(x;\theta),y)\tag{5.28}$$

$$\text{Cost(w,b)}$$

## 5.6.1 The Gradient For Logistic Regression

In order to update θ, we need a definition for the gradient ∇L( f(x;θ),y). Recall that for logistic regression, the cross-entropy loss function is:

$$L_{\rm CE}(\hat{y},y)=-\left[y\log\sigma({\bf w}\cdot{\bf x}+b)+(1-y)\log\left(1-\sigma({\bf w}\cdot{\bf x}+b)\right)\right]\tag{5.29}$$
It turns out that the derivative of this function for one observation vector x is Eq. 5.30 (the interested reader can see Section 5.10 for the derivation of this equation):

$$\partial L_{\rm CE}(\hat{y},y)=[\sigma({\bf w}\cdot{\bf x}+b)-y]x_{j}\tag{5.30}$$ $$=(\hat{y}-y)x_{j}$$
You'll also sometimes see this equation in the equivalent form:

$$\partial L_{\rm CE}(\hat{y},y)\over\partial w_{j}}=-(y-\hat{y})x_{j}\tag{5.31}$$
Note in these equations that the gradient with respect to a single weight w j represents a very intuitive value: the difference between the true y and our estimated
ˆy = σ(w · x + b) for that observation, multiplied by the corresponding input value x j.

## 5.6.2 The Stochastic Gradient Descent Algorithm

Stochastic gradient descent is an online algorithm that minimizes the loss function by computing its gradient after each training example, and nudging θ in the right direction (the opposite direction of the gradient). (An "online algorithm" is one that processes its input example by example, rather than waiting until it sees the entire input.) Fig. 5.6 shows the algorithm.

The learning rate η is a **hyperparameter** that must be adjusted. If it's too high, hyperparameter the learner will take steps that are too large, overshooting the minimum of the loss function. If it's too low, the learner will take steps that are too small, and take too long to get to the minimum. It is common to start with a higher learning rate and then slowly decrease it, so that it is a function of the iteration k of training; the notation
ηk can be used to mean the value of the learning rate at iteration k.

We'll discuss hyperparameters in more detail in Chapter 7, but in short, they are a special kind of parameter for any machine learning model. Unlike regular parameters of a model (weights like w and b), which are learned by the algorithm from the training set, hyperparameters are special parameters chosen by the algorithm designer that affect how the algorithm works.

## 5.6.3 Working Through An Example

Let's walk through a single step of the gradient descent algorithm. We'll use a simplified version of the example in Fig. 5.2 as it sees a single observation x, whose correct value is y = 1 (this is a positive review), and with a feature vector x = [x1,x2]
consisting of these two features:
x1 = 3
(count of positive lexicon words)
x2 = 2
(count of negative lexicon words)
function STOCHASTIC GRADIENT DESCENT(L(), f(), x, y) **returns** θ
# where: L is the loss function #
f is a function parameterized by θ
#
x is the set of training inputs x(1), x(2)*,...,* x(m)
#
y is the set of training outputs (labels) y(1), y(2)*,...,* y(m)
θ ←0
repeat til done
# see caption For each training tuple (x(i), y(i)) (in random order)
1. Optional (for reporting):
# How are we doing on this tuple?

Compute ˆy(i) =
f(x(i);θ)
# What is our estimated output ˆy?

Compute the loss L(ˆy(i),y(i)) # How far off is ˆy(i) from the true output y(i)?

2. g←∇θL( f(x(i);θ),y(i))
# How should we move θ to maximize loss?

3. θ ←θ − η g
# Go the other way instead return θ
Let's assume the initial weights and bias in θ 0 are all set to 0, and the initial learning rate η is 0.1:

$$w_{1}=w_{2}=b\ =\ 0$$ $$\eta\ =\ 0.1$$
The single update step requires that we compute the gradient, multiplied by the learning rate

$$\theta^{t+1}=\theta^{t}-\eta\nabla_{\theta}L(f(x^{(i)};\theta),y^{(i)})$$
In our mini example there are three parameters, so the gradient vector has 3 dimensions, for w1, w2, and b. We can compute the first gradient as follows:

∂LCE(ˆy,y) ∂w1 ∂LCE(ˆy,y) ∇w,bL =           ∂w2 ∂LCE(ˆy,y) ∂b  (σ(w ·x+b)−y)x1 (σ(w ·x+b)−y)x2 σ(w ·x+b)−y  =  (σ(0)−1)x1 (σ(0)−1)x2 σ(0)−1  =  −0.5x1 −0.5x2 −0.5  =  −1.5 −1.0 −0.5    =
Now that we have a gradient, we compute the new parameter vector θ 1 by moving
θ 0 in the opposite direction from the gradient:

θ 1 =        w1 w2 b −η  −1.5 −1.0 −0.5  =  .15 .1 .05 
So after one step of gradient descent, the weights have shifted to be: w1 = .15, w2 = .1, and b = .05.

Note that this observation x happened to be a positive example. We would expect that after seeing more negative examples with high counts of negative words, that the weight w2 would shift to have a negative value.

## 5.6.4 Mini-Batch Training

Stochastic gradient descent is called stochastic because it chooses a single random example at a time, moving the weights so as to improve performance on that single example. That can result in very choppy movements, so it's common to compute the gradient over batches of training instances rather than a single instance.

For example in **batch training** we compute the gradient over the entire dataset.

batch training By seeing so many examples, batch training offers a superb estimate of which direction to move the weights, at the cost of spending a lot of time processing every single example in the training set to compute this perfect direction.

A compromise is **mini-batch** training: we train on a group of m examples (permini-batch haps 512, or 1024) that is less than the whole dataset. (If m is the size of the dataset, then we are doing **batch** gradient descent; if m = 1, we are back to doing stochastic gradient descent.) Mini-batch training also has the advantage of computational efficiency. The mini-batches can easily be vectorized, choosing the size of the minibatch based on the computational resources. This allows us to process all the examples in one mini-batch in parallel and then accumulate the loss, something that's not possible with individual or batch training.

We just need to define mini-batch versions of the cross-entropy loss function we defined in Section 5.5 and the gradient in Section 5.6.1. Let's extend the crossentropy loss for one example from Eq. 5.23 to mini-batches of size m. We'll continue to use the notation that x(i) and y(i) mean the ith training features and training label, respectively. We make the assumption that the training examples are independent:

$$\log p(\mbox{training labels})=\log\prod_{i=1}^{m}p(y^{(i)}|x^{(i)})\tag{5.32}$$ $$=\sum_{i=1}^{m}\log p(y^{(i)}|x^{(i)})$$ $$=-\sum_{i=1}^{m}L_{\mbox{CE}}(\hat{y}^{(i)},y^{(i)})$$
Now the cost function for the mini-batch of m examples is the average loss for each example:

$$Cost(\hat{y},y)=\frac{1}{m}\sum_{i=1}^{m}L_{\rm CE}(\hat{y}^{(i)},y^{(i)})\tag{5.33}$$ $$=-\frac{1}{m}\sum_{i=1}^{m}y^{(i)}\log\sigma(\mathbf{w}\cdot\mathbf{x}^{(i)}+b)+(1-y^{(i)})\log\left(1-\sigma(\mathbf{w}\cdot\mathbf{x}^{(i)}+b)\right)$$
The mini-batch gradient is the average of the individual gradients from Eq. 5.30:

$$\partial Cost(\hat{y},y)=\frac{1}{m}\sum_{i=1}^{m}\left[\sigma(\mathbf{w}\cdot\mathbf{x}^{(i)}+b)-y^{(i)}\right]x_{j}^{(i)}\tag{5.34}$$
Instead of using the sum notation, we can more efficiently compute the gradient in its matrix form, following the vectorization we saw on page 7, where we have a matrix X of size [m× f] representing the m inputs in the batch, and a vector y of size
[m×1] representing the correct outputs:

$$\partial Cost(\hat{y},y)=\frac{1}{m}\left(\hat{y}-y\right)^{\intercal}\mathbf{X}\tag{5.35}$$ $$=\frac{1}{m}\left(\sigma(\mathbf{Xw}+\mathbf{b})-y\right)^{\intercal}\mathbf{X}$$

## 5.7 Regularization

Numquam ponenda est pluralitas sine necessitate
'Plurality should never be proposed unless needed'
William of Occam There is a problem with learning weights that make the model perfectly match the training data. If a feature is perfectly predictive of the outcome because it happens to only occur in one class, it will be assigned a very high weight. The weights for features will attempt to perfectly fit details of the training set, in fact too perfectly, modeling noisy factors that just accidentally correlate with the class. This problem is called **overfitting**. A good model should be able to **generalize** well from the training overfitting generalize data to the unseen test set, but a model that overfits will have poor generalization.

To avoid overfitting, a new **regularization** term R(θ) is added to the objective regularization function in Eq. 5.25, resulting in the following objective for a batch of m examples (slightly rewritten from Eq. 5.25 to be maximizing log probability rather than minimizing loss, and removing the 1
m term which doesn't affect the argmax):

$$\hat{\theta}=\underset{\theta}{\operatorname{argmax}}\sum_{i=1}^{m}\log P(y^{(i)}|x^{(i)})-\alpha R(\theta)\tag{5.36}$$
The new regularization term R(θ) is used to penalize large weights. Thus a setting of the weights that matches the training data perfectly— but uses many weights with high values to do so—will be penalized more than a setting that matches the data a little less well, but does so using smaller weights. There are two common ways to compute this regularization term R(θ). **L2 regularization** is a quadratic function of L2
regularization the weight values, named because it uses the (square of the) L2 norm of the weight values. The L2 norm, ||θ||2, is the same as the **Euclidean distance** of the vector θ
from the origin. If θ consists of n weights, then:

$$R(\theta)=||\theta||_{2}^{2}=\sum_{j=1}^{n}\theta_{j}^{2}\tag{5.37}$$
The L2 regularized objective function becomes:

$$\hat{\theta}=\underset{\theta}{\operatorname{argmax}}\left[\sum_{i=1}^{m}\log P(y^{(i)}|x^{(i)})\right]-\alpha\sum_{j=1}^{n}\theta_{j}^{2}\tag{5.38}$$
L1 regularization is a linear function of the weight values, named after the L1 norm L1
regularization
||W||1, the sum of the absolute values of the weights, or **Manhattan distance** (the

Manhattan distance is the distance you'd have to walk between two points in a city with a street grid like New York):

$$R(\theta)\ =\ ||\theta||_{1}=\sum_{i=1}^{n}|\theta_{i}|\tag{5.39}$$

The L1 regularized objective function becomes:

$$\hat{\theta}\ =\ \mathop{\rm argmax}_{\theta}\left[\sum_{i=1}^{m}\log P(y^{(i)}|x^{(i)})\right]-\alpha\sum_{j=1}^{n}|\theta_{j}|\tag{5.40}$$
These kinds of regularization come from statistics, where L1 regularization is called lasso regression (Tibshirani, 1996) and L2 regularization is called **ridge regression**, lasso ridge and both are commonly used in language processing. L2 regularization is easier to optimize because of its simple derivative (the derivative of θ 2 is just 2θ), while L1 regularization is more complex (the derivative of |θ| is non-continuous at zero).

But while L2 prefers weight vectors with many small weights, L1 prefers sparse solutions with some larger weights but many more weights set to zero. Thus L1 regularization leads to much sparser weight vectors, that is, far fewer features.

Both L1 and L2 regularization have Bayesian interpretations as constraints on the prior of how weights should look. L1 regularization can be viewed as a Laplace prior on the weights. L2 regularization corresponds to assuming that weights are distributed according to a Gaussian distribution with mean µ = 0. In a Gaussian or normal distribution, the further away a value is from the mean, the lower its probability (scaled by the variance σ). By using a Gaussian prior on the weights, we are saying that weights prefer to have the value 0. A Gaussian for a weight θj is

(5.41) −(θj − µj)2 2σ2 j   ! 2πσ2 j exp 1 q
If we multiply each weight by a Gaussian prior on the weight, we are thus maximizing the following constraint:

(5.42) −(θj − µj)2 ˆθ = argmax θ 2σ2 j   ! i=1 P(y(i)|x(i))× j=1 2πσ2 j exp m Y n Y 1 q which in log space, with $\mu=0$, and assuming $2\sigma^{2}=1$, corresponds to

$$\hat{\theta}=\mathop{\rm argmax}_{\theta}\sum_{i=1}^{m}\log P(y^{(i)}|x^{(i)})-\alpha\sum_{j=1}^{n}\theta_{j}^{2}\tag{5.43}$$
which is in the same form as Eq. 5.38.

## 5.8 Learning In Multinomial Logistic Regression

The loss function for multinomial logistic regression generalizes the loss function for binary logistic regression from 2 to K classes. Recall that that the cross-entropy loss for binary logistic regression (repeated from Eq. 5.23) is:

$$L_{\rm CE}(\hat{y},y)=-\log p(y|x)\ =\ -\left[y\log\hat{y}+(1-y)\log(1-\hat{y})\right]\tag{5.44}$$
The loss function for multinomial logistic regression generalizes the two terms in Eq. 5.44 (one that is non-zero when y = 1 and one that is non-zero when y = 0) to K terms. As we mentioned above, for multinomial regression we'll represent both y and ˆy as vectors. The true label y is a vector with K elements, each corresponding to a class, with yc = 1 if the correct class is c, with all other elements of y being 0.

And our classifier will produce an estimate vector with K elements ˆy, each element
ˆyk of which represents the estimated probability p(yk = 1|x).

The loss function for a single example x, generalizing from binary logistic regression, is the sum of the logs of the K output classes, each weighted by their probability yk (Eq. 5.45). This turns out to be just the negative log probability of the correct class c (Eq. 5.46):

LCE(ˆy,y) = − k=1 yk log ˆyk (5.45) K X = −log ˆyc, (where c is the correct class) (5.46) = −log ˆp(yc = 1|x) (where c is the correct class) = −log exp(wc ·x+bc) PK j=1 exp(wj ·x+bj) (c is the correct class) (5.47)
How did we get from Eq. 5.45 to Eq. 5.46? Because only one class (let's call it c) is the correct one, the vector y takes the value 1 only for this value of k, i.e., has yc = 1
and yj = 0 ∀ j ̸= c. That means the terms in the sum in Eq. 5.45 will all be 0 except for the term corresponding to the true class c. Hence the cross-entropy loss is simply the log of the output probability corresponding to the correct class, and we therefore also call Eq. 5.46 the **negative log likelihood loss**.

negative log likelihood loss Of course for gradient descent we don't need the loss, we need its gradient. The gradient for a single example turns out to be very similar to the gradient for binary logistic regression, (ˆy−y)x, that we saw in Eq. 5.30. Let's consider one piece of the gradient, the derivative for a single weight. For each class k, the weight of the ith element of input x is wk,i. What is the partial derivative of the loss with respect to wk,i? This derivative turns out to be just the difference between the true value for the class k (which is either 1 or 0) and the probability the classifier outputs for class k, weighted by the value of the input xi corresponding to the ith element of the weight vector for class k:

$$\frac{\partial L_{\text{CE}}}{\partial w_{k,i}}=-(y_{k}-\hat{y}_{k})x_{i}\tag{5.48}$$ $$=-(y_{k}-p(y_{k}=1|x))x_{i}$$ $$=-\left(y_{k}-\frac{\exp\left(\mathbf{w_{k}\cdot x+b_{k}}\right)}{\sum_{j=1}^{K}\exp\left(\mathbf{w_{j}\cdot x+b_{j}}\right)}\right)x_{i}$$

We'll return to this case of the gradient for softmax regression when we introduce neural networks in Chapter 7, and at that time we'll also discuss the derivation of this gradient in equations Eq. $}}$.

## 5.9 Interpreting Models

Often we want to know more than just the correct classification of an observation. We want to know why the classifier made the decision it did. That is, we want our decision to be **interpretable**. Interpretability can be hard to define strictly, but the interpretable core idea is that as humans we should know why our algorithms reach the conclusions they do. Because the features to logistic regression are often human-designed, one way to understand a classifier's decision is to understand the role each feature plays in the decision. Logistic regression can be combined with statistical tests (the likelihood ratio test, or the Wald test); investigating whether a particular feature is significant by one of these tests, or inspecting its magnitude (how large is the weight w associated with the feature?) can help us interpret why the classifier made the decision it makes. This is enormously important for building transparent models.

Furthermore, in addition to its use as a classifier, logistic regression in NLP and many other fields is widely used as an analytic tool for testing hypotheses about the effect of various explanatory variables (features). In text classification, perhaps we want to know if logically negative words (*no, not, never*) are more likely to be associated with negative sentiment, or if negative reviews of movies are more likely to discuss the cinematography. However, in doing so it's necessary to control for potential confounds: other factors that might influence sentiment (the movie genre, the year it was made, perhaps the length of the review in words). Or we might be studying the relationship between NLP-extracted linguistic features and non-linguistic outcomes (hospital readmissions, political outcomes, or product sales), but need to control for confounds (the age of the patient, the county of voting, the brand of the product). In such cases, logistic regression allows us to test whether some feature is associated with some outcome above and beyond the effect of other features.

## 5.10 Advanced: Deriving The Gradient Equation

In this section we give the derivation of the gradient of the cross-entropy loss function LCE for logistic regression. Let's start with some quick calculus refreshers.

First, the derivative of ln(x):

$\frac{d}{dx}\ln(x)=\frac{1}{x}$ (5.49)
Second, the (very elegant) derivative of the sigmoid:

$d\sigma(z)=\sigma(z)(1-\sigma(z))$ (5.50)
Finally, the **chain rule** of derivatives. Suppose we are computing the derivative chain rule of a composite function f(x) = u(v(x)). The derivative of f(x) is the derivative of u(x) with respect to v(x) times the derivative of v(x) with respect to x:

$$\frac{df}{dx}\ =\ \frac{du}{dv}\cdot\frac{dv}{dx}\tag{5.51}$$

First, we want to know the derivative of the loss function with respect to a single weight $w_{j}$ (we'll need to compute it for each weight, and for the bias): $$\frac{\partial L_{\rm CE}}{\partial w_{j}}=\frac{\partial}{\partial w_{j}}-\left[y\log\sigma({\bf w}\cdot{\bf x}+b)+(1-y)\log\left(1-\sigma({\bf w}\cdot{\bf x}+b)\right)\right]\tag{5.52}$$ $$=-\left[\frac{\partial}{\partial w_{j}}y\log\sigma({\bf w}\cdot{\bf x}+b)+\frac{\partial}{\partial w_{j}}(1-y)\log\left[1-\sigma({\bf w}\cdot{\bf x}+b)\right]\right]$$
Next, using the chain rule, and relying on the derivative of log:

$$\frac{\partial L_{\rm CE}}{\partial w_{j}}=-\frac{y}{\sigma({\bf w}\cdot{\bf x}+b)}\frac{\partial}{\partial w_{j}}\sigma({\bf w}\cdot{\bf x}+b)-\frac{1-y}{1-\sigma({\bf w}\cdot{\bf x}+b)}\frac{\partial}{\partial w_{j}}1-\sigma({\bf w}\cdot{\bf x}+b)\tag{5.53}$$
Rearranging terms:

$$\frac{\partial L_{\rm CE}}{\partial w_{j}}=-\left[\frac{y}{\sigma({\bf w}\cdot{\bf x}+b)}-\frac{1-y}{1-\sigma({\bf w}\cdot{\bf x}+b)}\right]\frac{\partial}{\partial w_{j}}\sigma({\bf w}\cdot{\bf x}+b)\tag{5.54}$$
And now plugging in the derivative of the sigmoid, and using the chain rule one more time, we end up with Eq. 5.55:

$$\frac{\partial L_{\rm CE}}{\partial w_{j}}=-\left[\frac{y-\sigma({\bf w}\cdot{\bf x}+b)}{\sigma({\bf w}\cdot{\bf x}+b)[1-\sigma({\bf w}\cdot{\bf x}+b)]}\right]\sigma({\bf w}\cdot{\bf x}+b)[1-\sigma({\bf w}\cdot{\bf x}+b)]\frac{\partial({\bf w}\cdot{\bf x}+b)}{\partial w_{j}}\tag{5.55}$$ $$=-\left[\frac{y-\sigma({\bf w}\cdot{\bf x}+b)}{\sigma({\bf w}\cdot{\bf x}+b)[1-\sigma({\bf w}\cdot{\bf x}+b)]}\right]\sigma({\bf w}\cdot{\bf x}+b)[1-\sigma({\bf w}\cdot{\bf x}+b)]x_{j}$$ $$=-[y-\sigma({\bf w}\cdot{\bf x}+b)]x_{j}$$ $$=[\sigma({\bf w}\cdot{\bf x}+b)-y]x_{j}$$

## 5.11 Summary

This chapter introduced the **logistic regression** model of **classification**.

- Logistic regression is a supervised machine learning classifier that extracts
real-valued features from the input, multiplies each by a weight, sums them,
and passes the sum through a **sigmoid** function to generate a probability. A
threshold is used to make a decision.
- Logistic regression can be used with two classes (e.g., positive and negative
sentiment) or with multiple classes (**multinomial logistic regression**, for example for n-ary text classification, part-of-speech labeling, etc.).
- Multinomial logistic regression uses the **softmax** function to compute probabilities.
- The weights (vector w and bias b) are learned from a labeled training set via a
loss function, such as the **cross-entropy loss**, that must be minimized.
- Minimizing this loss function is a **convex optimization** problem, and iterative
algorithms like **gradient descent** are used to find the optimal weights.
- **Regularization** is used to avoid overfitting.
- Logistic regression is also one of the most useful analytic tools, because of its
ability to transparently study the importance of individual features.

## Bibliographical And Historical Notes

Logistic regression was developed in the field of statistics, where it was used for the analysis of binary data by the 1960s, and was particularly common in medicine (Cox, 1969). Starting in the late 1970s it became widely used in linguistics as one of the formal foundations of the study of linguistic variation (Sankoff and Labov, 1979).

Nonetheless, logistic regression didn't become common in natural language processing until the 1990s, when it seems to have appeared simultaneously from two directions. The first source was the neighboring fields of information retrieval and speech processing, both of which had made use of regression, and both of which lent many other statistical techniques to NLP. Indeed a very early use of logistic regression for document routing was one of the first NLP applications to use (LSI)
embeddings as word representations (Sch¨utze et al., 1995).

At the same time in the early 1990s logistic regression was developed and applied to NLP at IBM Research under the name **maximum entropy** modeling or maximum entropy maxent (Berger et al., 1996), seemingly independent of the statistical literature. Under that name it was applied to language modeling (Rosenfeld, 1996), part-of-speech tagging (Ratnaparkhi, 1996), parsing (Ratnaparkhi, 1997), coreference resolution (Kehler, 1997), and text classification (Nigam et al., 1999).

More on classification can be found in machine learning textbooks (Hastie et al.

2001, Witten and Frank 2005, Bishop 2006, Murphy 2012).

## Exercises

Berger, A., S. A. Della Pietra, and V. J. Della Pietra. 1996. A
maximum entropy approach to natural language processing. *Computational Linguistics*, 22(1):39–71.
Bishop, C. M. 2006. Pattern recognition and machine learning. Springer.
Cox, D. 1969. *Analysis of Binary Data*. Chapman and Hall,
London.
Hastie, T., R. J. Tibshirani, and J. H. Friedman. 2001. The
Elements of Statistical Learning. Springer.
Kehler, A. 1997. Probabilistic coreference in information
extraction. *EMNLP*.
Murphy, K. P. 2012. Machine learning: A probabilistic perspective. MIT Press.
Ng, A. Y. and M. I. Jordan. 2002.
On discriminative vs.
generative classifiers: A comparison of logistic regression and naive bayes. *NeurIPS*.
Nigam, K., J. D. Lafferty, and A. McCallum. 1999. Using
maximum entropy for text classification. IJCAI-99 workshop on machine learning for information filtering.
Ratnaparkhi, A. 1996. A maximum entropy part-of-speech
tagger. *EMNLP*.
Ratnaparkhi, A. 1997.
A linear observed time statistical
parser based on maximum entropy models. *EMNLP*.
Rosenfeld, R. 1996. A maximum entropy approach to adaptive statistical language modeling. Computer Speech and
Language, 10:187–228.
Sankoff, D. and W. Labov. 1979. On the uses of variable
rules. *Language in society*, 8(2-3):189–222.
Sch¨utze, H., D. A. Hull, and J. Pedersen. 1995. A comparison of classifiers and document representations for the routing problem. *SIGIR-95*.
Tibshirani, R. J. 1996. Regression shrinkage and selection
via the lasso. Journal of the Royal Statistical Society. Series B (Methodological), 58(1):267–288.
Wang, S. and C. D. Manning. 2012. Baselines and bigrams:
Simple, good sentiment and topic classification. *ACL*.
Witten, I. H. and E. Frank. 2005.
Data Mining: Practical Machine Learning Tools and Techniques, 2nd edition. Morgan Kaufmann.